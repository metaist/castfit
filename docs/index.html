<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>castfit API documentation</title>
<meta name="description" content="castfit: basic type casting â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>castfit</code></h1>
</header>
<section id="section-intro">
<p>castfit: basic type casting</p>
<p align="center">
<a href="https://metaist.github.io/castfit/"><img alt="castfit" width="200" src="https://raw.githubusercontent.com/metaist/castfit/main/cats-fit.png" /></a><br />
<em>Do you even castfit?<br />If it fits, I sits.</em>
</p>
<p align="center">
<a href="https://github.com/metaist/castfit/actions/workflows/ci.yaml"><img alt="Build" src="https://img.shields.io/github/actions/workflow/status/metaist/castfit/.github/workflows/ci.yaml?branch=main&logo=github"/></a>
<!-- <a href="https://github.com/metaist/castfit/issues"><img alt="Issues" src="https://img.shields.io/github/issues/metaist/castfit?logo=github"/></a> -->
<!-- <br /> -->
<a href="https://pypi.org/project/castfit"><img alt="PyPI" src="https://img.shields.io/pypi/v/castfit.svg?color=blue" /></a>
<a href="https://pypi.org/project/castfit"><img alt="Supported Python Versions" src="https://img.shields.io/pypi/pyversions/castfit" /></a>
<!-- <br />
<a href="https://metaist.github.io/castfit/"><img alt="Docs" src="https://img.shields.io/badge/docs-read-%2" /></a>
<a href="https://github.com/metaist/castfit/blob/main/CHANGELOG.md"><img alt="Changelog" src="https://img.shields.io/badge/changelog-read-%2"></a>
<a href="https://github.com/metaist/castfit/blob/main/LICENSE.md"><img alt="License" src="https://img.shields.io/github/license/metaist/castfit" /></a> -->
</p>
<h2 id="why">Why?</h2>
<p>I'm writing more and more type-checked code, but I often get a bunch of strings I need to convert (e.g., from <a href="https://github.com/docopt/docopt"><code>docopt</code></a>).</p>
<ul>
<li><a href="https://github.com/pydantic/pydantic"><code>pydantic</code></a> feels heavy.</li>
<li><a href="https://github.com/dreamgonfly/type-docopt"><code>type-docopt</code></a> uses a new syntax.</li>
<li><a href="https://github.com/bottlepy/bottle"><code>bottle</code></a> seems like good inspiration for small, useful libraries.</li>
</ul>
<h2 id="install">Install</h2>
<pre><code class="language-bash">python -m pip install castfit
</code></pre>
<h2 id="example">Example</h2>
<pre><code class="language-python">from pathlib import Path
from castfit import castfit

class Cat:
  name: str
  age: int
  weight: float
  logo: Path

bob = castfit(Cat, dict(name=&quot;Bob&quot;, age=&quot;4&quot;, weight=&quot;3.2&quot;, logo=&quot;./bob.png&quot;))
assert bob.name == &quot;Bob&quot;
assert bob.age == 4
assert bob.weight == 3.2
assert bob.logo == Path(&quot;./bob.png&quot;)
</code></pre>
<h2 id="license">License</h2>
<p><a href="https://github.com/metaist/castfit/blob/main/LICENSE.md">MIT License</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;castfit: basic type casting

.. include:: ../../README.md
   :start-line: 2
&#34;&#34;&#34;

# std
from __future__ import annotations
from dataclasses import is_dataclass
from datetime import datetime
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import get_args
from typing import get_origin
from typing import get_type_hints
from typing import List
from typing import Literal
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Set
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union
import sys

if sys.version_info &gt;= (3, 11):  # pragma: no cover
    from types import NoneType
    from typing import Never
else:  # pragma: no cover
    NoneType = type(None)
    Never = NoReturn

__all__ = [
    &#34;__version__&#34;,
    &#34;__pubdate__&#34;,
    #
    # imported
    &#34;Never&#34;,
    &#34;NoneType&#34;,
    #
    # types
    &#34;Ignored&#34;,
    &#34;TypeForm&#34;,
    &#34;CheckFn&#34;,
    &#34;Checks&#34;,
    &#34;CastFn&#34;,
    &#34;Casts&#34;,
    #
    # top-level API
    &#34;castfit&#34;,
    &#34;is_type&#34;,
    &#34;to_type&#34;,
    #
    # extensions
    &#34;checks_type&#34;,
    &#34;casts_to&#34;,
    #
    # lower-level API
    &#34;get_origin_type&#34;,
    &#34;setattrs&#34;,
    &#34;is_any&#34;,
    &#34;to_any&#34;,
    &#34;is_never&#34;,
    &#34;to_never&#34;,
    &#34;is_none&#34;,
    &#34;to_none&#34;,
    &#34;is_literal&#34;,
    &#34;to_literal&#34;,
    &#34;is_union&#34;,
    &#34;to_union&#34;,
    &#34;to_bytes&#34;,
    &#34;to_str&#34;,
    &#34;is_list&#34;,
    &#34;to_list&#34;,
    &#34;is_set&#34;,
    &#34;to_set&#34;,
    &#34;is_dict&#34;,
    &#34;to_dict&#34;,
    &#34;is_tuple&#34;,
    &#34;to_tuple&#34;,
    &#34;to_datetime&#34;,
]

__version__ = &#34;0.1.0&#34;
__pubdate__ = &#34;2023-12-15T12:12:04Z&#34;

K = TypeVar(&#34;K&#34;)
&#34;&#34;&#34;Type variable for keys.&#34;&#34;&#34;

T = TypeVar(&#34;T&#34;)
&#34;&#34;&#34;Type variable for values.&#34;&#34;&#34;

Ignored = Optional[Any]
&#34;&#34;&#34;A function argument that is ignored.&#34;&#34;&#34;

TypeForm = Union[Type[T], Any]
&#34;&#34;&#34;`Type` and special forms like `All`, `Union`, etc.&#34;&#34;&#34;
# NOTE: We want just `Type[T]`, but `mypy` treats special forms as `object`.

CheckFn = Callable[[Any, TypeForm[Any]], bool]
&#34;&#34;&#34;Function signature that checks if a value is of a type.&#34;&#34;&#34;

Checks = Dict[TypeForm[Any], CheckFn]
&#34;&#34;&#34;Type of internal mapping of types to check functions.&#34;&#34;&#34;

TYPE_CHECKS: Checks = {}
&#34;&#34;&#34;Mapping of types to check functions.&#34;&#34;&#34;

CastFn = Callable[[Any, TypeForm[T]], T]
&#34;&#34;&#34;Function signature that maps a value to a type.&#34;&#34;&#34;

Casts = Dict[TypeForm[Any], CastFn[Any]]
&#34;&#34;&#34;Type of internal mapping of types to cast functions.&#34;&#34;&#34;

TYPE_CASTS: Casts = {}
&#34;&#34;&#34;Mapping of types to cast functions.&#34;&#34;&#34;


@overload
def castfit(spec: Type[T], data: Dict[str, Any]) -&gt; T:
    ...


@overload
def castfit(spec: T, data: Dict[str, Any]) -&gt; T:
    ...


def castfit(spec, data):  # type: ignore[no-untyped-def]
    &#34;&#34;&#34;Construct a `spec` using `data` that has been cast appropriately.&#34;&#34;&#34;
    type_hints = get_type_hints(spec)
    typed_data: Dict[str, Any] = {
        name: to_type(value, type_hints.get(name, Any)) for name, value in data.items()
    }
    if is_dataclass(spec) and isinstance(spec, type):
        return spec(**typed_data)

    result = spec
    if isinstance(spec, type):
        result = spec()
    return setattrs(result, **typed_data)


def is_type(value: Any, kind: TypeForm[Any], checks: Optional[Checks] = None) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is of a type compatible with `kind`.&#34;&#34;&#34;
    # TODO [2024-10-14]: @ py3.8 EOL, make return type `TypeGuard[T]`
    checks = checks or TYPE_CHECKS
    origin = get_origin(kind) or kind
    checker = checks.get(origin)
    if checker:
        return checker(value, kind)
    return isinstance(value, kind)


def to_type(
    value: Any,
    kind: TypeForm[T],
    checks: Optional[Checks] = None,
    casts: Optional[Casts] = None,
) -&gt; T:
    &#34;&#34;&#34;Try to cast `value` to the type of `kind`.&#34;&#34;&#34;
    checks = checks or TYPE_CHECKS
    if is_type(value, kind, checks):  # already done
        return cast(T, value)

    casts = casts or TYPE_CASTS
    origin = get_origin(kind) or kind
    caster = casts.get(origin)
    if caster:
        return cast(T, caster(value, kind))

    try:
        return cast(T, origin(value))  # type: ignore[call-arg]
    except Exception:
        raise TypeError(f&#34;Cannot cast {value!r} to {kind}&#34;)


def get_origin_type(given: TypeForm[T]) -&gt; Type[T]:
    &#34;&#34;&#34;Returns the `given` type, its origin, or `type(obj)`.

    See: [typing.get_origin](https://docs.python.org/3/library/typing.html#typing.get_origin)
    &#34;&#34;&#34;
    origin = get_origin(given) or given
    if isinstance(origin, type):
        return cast(Type[T], origin)  # cast due to mypy
    return cast(Type[T], type(given))  # cast due to mypy


def setattrs(obj: object, **values: Dict[str, Any]) -&gt; object:
    &#34;&#34;&#34;Like `setattr()` but for multiple values and returns the object.&#34;&#34;&#34;
    for name, val in values.items():
        setattr(obj, name, val)
    return obj


def checks_type(*types: Any) -&gt; Callable[[CheckFn], CheckFn]:
    &#34;&#34;&#34;Define a type-checker for one or more types.&#34;&#34;&#34;

    def _factory(func: CheckFn) -&gt; CheckFn:
        for t in types:
            TYPE_CHECKS[t] = func
        return func

    return _factory


def casts_to(*types: Any) -&gt; Callable[[T], T]:
    &#34;&#34;&#34;Define a type-caster for one or more types.&#34;&#34;&#34;

    def _factory(func: T) -&gt; T:
        for t in types:
            TYPE_CASTS[t] = cast(CastFn[Any], func)
        return func

    return _factory


@checks_type(Any)
def is_any(_value: Ignored = None, _kind: Ignored = Any) -&gt; bool:
    &#34;&#34;&#34;Always return `True`.&#34;&#34;&#34;
    return True


@casts_to(Any)
def to_any(value: T, _kind: Ignored = Any) -&gt; T:
    &#34;&#34;&#34;Always return `value`.&#34;&#34;&#34;
    return value


@checks_type(Never, NoReturn)
def is_never(_value: Ignored = None, _kind: Ignored = Never) -&gt; bool:
    &#34;&#34;&#34;Always return `False`.&#34;&#34;&#34;
    return False


@casts_to(Never, NoReturn)
def to_never(value: Any, _kind: Ignored = Never) -&gt; NoReturn:
    &#34;&#34;&#34;Always raise a `TypeError`.&#34;&#34;&#34;
    raise TypeError(f&#34;Cannot cast {value!r} to Never (nothing can)&#34;)


@checks_type(NoneType)
def is_none(value: Any, _kind: Ignored = None) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is `None`.&#34;&#34;&#34;
    return value is None


@casts_to(NoneType)
def to_none(_value: Ignored = None, _kind: Ignored = None) -&gt; None:
    &#34;&#34;&#34;Always return `None`.&#34;&#34;&#34;
    return None


@checks_type(Literal)
def is_literal(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `Literal`.&#34;&#34;&#34;
    return value in get_args(kind)


@casts_to(Literal)
def to_literal(value: T, kind: TypeForm[T]) -&gt; T:
    &#34;&#34;&#34;Return `value` if it is one of the `Literal` values.&#34;&#34;&#34;
    if not is_literal(value, kind):
        raise TypeError(f&#34;Cannot cast {value!r} to {kind}&#34;)
    return value


@checks_type(Union)
def is_union(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `Union`.&#34;&#34;&#34;
    return any(is_type(value, val_type) for val_type in get_args(kind))


@casts_to(Union)
def to_union(value: Any, kind: TypeForm[T]) -&gt; T:
    for arg in get_args(kind):
        try:
            return cast(T, to_type(value, arg))
        except (TypeError, ValueError):
            pass
    raise TypeError(f&#34;Cannot cast {value!r} to {kind}&#34;)


@casts_to(bytes)
def to_bytes(value: Any, kind: Type[bytes] = bytes) -&gt; bytes:
    &#34;&#34;&#34;Cast `value` into `bytes`, encoding `str` as UTF-8 bytes if needed.&#34;&#34;&#34;
    if isinstance(value, str):
        return value.encode(&#34;utf-8&#34;)
    cls: Type[bytes] = get_origin_type(kind)
    return cls(value)


@casts_to(str)
def to_str(value: Any, kind: Type[str] = str) -&gt; str:
    &#34;&#34;&#34;Cast `value` into `str`, decoding `bytes` as UTF-8 strings if needed.&#34;&#34;&#34;
    if isinstance(value, bytes):
        return value.decode(&#34;utf-8&#34;)
    cls: Type[str] = get_origin_type(kind)
    return cls(value)


@checks_type(list)
def is_list(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `list`.&#34;&#34;&#34;
    if not isinstance(value, list):
        return False
    if len(value) == 0:  # list() matches List[Any]
        return True
    vt = get_args(kind)[0]
    return all(is_type(v, vt) for v in value)


@casts_to(list)
def to_list(value: Any, kind: TypeForm[List[T]] = list) -&gt; List[T]:
    &#34;&#34;&#34;Cast `value` into `list`.&#34;&#34;&#34;
    cls: Type[List[T]] = get_origin_type(kind)
    val_type = get_args(kind)[0]
    return cls(to_type(val, val_type) for val in value)


@checks_type(set)
def is_set(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `set`.&#34;&#34;&#34;
    if not isinstance(value, set):
        return False
    if len(value) == 0:  # set() matches Set[Any]
        return True
    val_type = get_args(kind)[0]
    return all(is_type(val, val_type) for val in value)


@casts_to(set)
def to_set(value: Any, kind: TypeForm[Set[T]] = set) -&gt; Set[T]:
    &#34;&#34;&#34;Cast `value` into `set`.&#34;&#34;&#34;
    cls: Type[Set[T]] = get_origin_type(kind)
    val_type = get_args(kind)[0]
    return cls(to_type(val, val_type) for val in value)


@checks_type(dict)
def is_dict(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `dict`.&#34;&#34;&#34;
    if not isinstance(value, dict):
        return False
    if len(value) == 0:  # dict() matches Dict[Any, Any]
        return True
    kt, vt = get_args(kind)
    return all(is_type(k, kt) and is_type(v, vt) for k, v in value.items())


@casts_to(dict)
def to_dict(value: Any, kind: TypeForm[Dict[K, T]] = dict) -&gt; Dict[K, T]:
    &#34;&#34;&#34;Cast `value` into a `dict`.&#34;&#34;&#34;
    cls: Type[Dict[K, T]] = get_origin_type(kind)
    if len(value) == 0:
        return cls()
    kt, vt = get_args(kind)
    return cls({to_type(k, kt): to_type(v, vt) for k, v in value.items()})


@checks_type(tuple)
def is_tuple(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `tuple`.&#34;&#34;&#34;
    args = get_args(kind)
    if not isinstance(value, tuple):
        return False
    if len(args) == 0 or args == ((),):  # special empty-tuple format
        return value == ()
    if len(args) &gt; 1 and args[1] == ...:
        args = args[:1] * len(value)
    return len(value) == len(args) and all(is_type(v, vt) for v, vt in zip(value, args))


@casts_to(tuple)
def to_tuple(value: Any, kind: TypeForm[Tuple[Any, ...]] = tuple) -&gt; Tuple[Any, ...]:
    &#34;&#34;&#34;Cast `value` into a `tuple`.&#34;&#34;&#34;
    cls: Type[Tuple[Any, ...]] = get_origin_type(kind)
    args = get_args(kind)
    if len(value) == 0 and len(args) == 0 or args == ((),):
        return cls()
    if len(args) &gt; 1 and args[1] == ...:
        args = args[:1] * len(value)
    if len(value) &lt; len(args):
        raise ValueError(f&#34;Not enough values in {value!r} to cast to {kind}&#34;)
    return cls(to_type(val, val_type) for val, val_type in zip(value, args))


@casts_to(datetime)
def to_datetime(value: Any, kind: Type[datetime] = datetime) -&gt; datetime:
    &#34;&#34;&#34;Cast `value` into a `datetime`.&#34;&#34;&#34;
    cls: Type[datetime] = get_origin_type(kind)
    # TODO: Handle other kinds of casts (e.g., int -&gt; datetime)
    return cls.fromisoformat(value)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="castfit.Ignored"><code class="name">var <span class="ident">Ignored</span></code></dt>
<dd>
<div class="desc"><p>A function argument that is ignored.</p></div>
</dd>
<dt id="castfit.TypeForm"><code class="name">var <span class="ident">TypeForm</span></code></dt>
<dd>
<div class="desc"><p><code>Type</code> and special forms like <code>All</code>, <code>Union</code>, etc.</p></div>
</dd>
<dt id="castfit.CheckFn"><code class="name">var <span class="ident">CheckFn</span></code></dt>
<dd>
<div class="desc"><p>Function signature that checks if a value is of a type.</p></div>
</dd>
<dt id="castfit.Checks"><code class="name">var <span class="ident">Checks</span></code></dt>
<dd>
<div class="desc"><p>Type of internal mapping of types to check functions.</p></div>
</dd>
<dt id="castfit.CastFn"><code class="name">var <span class="ident">CastFn</span></code></dt>
<dd>
<div class="desc"><p>Function signature that maps a value to a type.</p></div>
</dd>
<dt id="castfit.Casts"><code class="name">var <span class="ident">Casts</span></code></dt>
<dd>
<div class="desc"><p>Type of internal mapping of types to cast functions.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="castfit.castfit"><code class="name flex">
<span>def <span class="ident">castfit</span></span>(<span>spec, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a <code>spec</code> using <code>data</code> that has been cast appropriately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def castfit(spec, data):  # type: ignore[no-untyped-def]
    &#34;&#34;&#34;Construct a `spec` using `data` that has been cast appropriately.&#34;&#34;&#34;
    type_hints = get_type_hints(spec)
    typed_data: Dict[str, Any] = {
        name: to_type(value, type_hints.get(name, Any)) for name, value in data.items()
    }
    if is_dataclass(spec) and isinstance(spec, type):
        return spec(**typed_data)

    result = spec
    if isinstance(spec, type):
        result = spec()
    return setattrs(result, **typed_data)</code></pre>
</details>
</dd>
<dt id="castfit.is_type"><code class="name flex">
<span>def <span class="ident">is_type</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[Any], checks:Â Optional[<a title="castfit.Checks" href="#castfit.Checks">Checks</a>]Â =Â None) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code>value</code> is of a type compatible with <code>kind</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_type(value: Any, kind: TypeForm[Any], checks: Optional[Checks] = None) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is of a type compatible with `kind`.&#34;&#34;&#34;
    # TODO [2024-10-14]: @ py3.8 EOL, make return type `TypeGuard[T]`
    checks = checks or TYPE_CHECKS
    origin = get_origin(kind) or kind
    checker = checks.get(origin)
    if checker:
        return checker(value, kind)
    return isinstance(value, kind)</code></pre>
</details>
</dd>
<dt id="castfit.to_type"><code class="name flex">
<span>def <span class="ident">to_type</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T], checks:Â Optional[<a title="castfit.Checks" href="#castfit.Checks">Checks</a>]Â =Â None, casts:Â Optional[<a title="castfit.Casts" href="#castfit.Casts">Casts</a>]Â =Â None) â€‘>Â ~T</span>
</code></dt>
<dd>
<div class="desc"><p>Try to cast <code>value</code> to the type of <code>kind</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_type(
    value: Any,
    kind: TypeForm[T],
    checks: Optional[Checks] = None,
    casts: Optional[Casts] = None,
) -&gt; T:
    &#34;&#34;&#34;Try to cast `value` to the type of `kind`.&#34;&#34;&#34;
    checks = checks or TYPE_CHECKS
    if is_type(value, kind, checks):  # already done
        return cast(T, value)

    casts = casts or TYPE_CASTS
    origin = get_origin(kind) or kind
    caster = casts.get(origin)
    if caster:
        return cast(T, caster(value, kind))

    try:
        return cast(T, origin(value))  # type: ignore[call-arg]
    except Exception:
        raise TypeError(f&#34;Cannot cast {value!r} to {kind}&#34;)</code></pre>
</details>
</dd>
<dt id="castfit.checks_type"><code class="name flex">
<span>def <span class="ident">checks_type</span></span>(<span>*types:Â Any) â€‘>Â Callable[[Callable[[Any,Â Union[Type[Any],Â Any]],Â bool]],Â Callable[[Any,Â Union[Type[Any],Â Any]],Â bool]]</span>
</code></dt>
<dd>
<div class="desc"><p>Define a type-checker for one or more types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checks_type(*types: Any) -&gt; Callable[[CheckFn], CheckFn]:
    &#34;&#34;&#34;Define a type-checker for one or more types.&#34;&#34;&#34;

    def _factory(func: CheckFn) -&gt; CheckFn:
        for t in types:
            TYPE_CHECKS[t] = func
        return func

    return _factory</code></pre>
</details>
</dd>
<dt id="castfit.casts_to"><code class="name flex">
<span>def <span class="ident">casts_to</span></span>(<span>*types:Â Any) â€‘>Â Callable[[~T],Â ~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Define a type-caster for one or more types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def casts_to(*types: Any) -&gt; Callable[[T], T]:
    &#34;&#34;&#34;Define a type-caster for one or more types.&#34;&#34;&#34;

    def _factory(func: T) -&gt; T:
        for t in types:
            TYPE_CASTS[t] = cast(CastFn[Any], func)
        return func

    return _factory</code></pre>
</details>
</dd>
<dt id="castfit.get_origin_type"><code class="name flex">
<span>def <span class="ident">get_origin_type</span></span>(<span>given:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T]) â€‘>Â Type[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the <code>given</code> type, its origin, or <code>type(obj)</code>.</p>
<p>See: <a href="https://docs.python.org/3/library/typing.html#typing.get_origin">typing.get_origin</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_origin_type(given: TypeForm[T]) -&gt; Type[T]:
    &#34;&#34;&#34;Returns the `given` type, its origin, or `type(obj)`.

    See: [typing.get_origin](https://docs.python.org/3/library/typing.html#typing.get_origin)
    &#34;&#34;&#34;
    origin = get_origin(given) or given
    if isinstance(origin, type):
        return cast(Type[T], origin)  # cast due to mypy
    return cast(Type[T], type(given))  # cast due to mypy</code></pre>
</details>
</dd>
<dt id="castfit.setattrs"><code class="name flex">
<span>def <span class="ident">setattrs</span></span>(<span>obj:Â object, **values:Â Dict[str,Â Any]) â€‘>Â object</span>
</code></dt>
<dd>
<div class="desc"><p>Like <code>setattr()</code> but for multiple values and returns the object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setattrs(obj: object, **values: Dict[str, Any]) -&gt; object:
    &#34;&#34;&#34;Like `setattr()` but for multiple values and returns the object.&#34;&#34;&#34;
    for name, val in values.items():
        setattr(obj, name, val)
    return obj</code></pre>
</details>
</dd>
<dt id="castfit.is_any"><code class="name flex">
<span>def <span class="ident">is_any</span></span>(<span>) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Always return <code>True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@checks_type(Any)
def is_any(_value: Ignored = None, _kind: Ignored = Any) -&gt; bool:
    &#34;&#34;&#34;Always return `True`.&#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="castfit.to_any"><code class="name flex">
<span>def <span class="ident">to_any</span></span>(<span>value:Â T) â€‘>Â ~T</span>
</code></dt>
<dd>
<div class="desc"><p>Always return <code>value</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(Any)
def to_any(value: T, _kind: Ignored = Any) -&gt; T:
    &#34;&#34;&#34;Always return `value`.&#34;&#34;&#34;
    return value</code></pre>
</details>
</dd>
<dt id="castfit.is_never"><code class="name flex">
<span>def <span class="ident">is_never</span></span>(<span>) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Always return <code>False</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@checks_type(Never, NoReturn)
def is_never(_value: Ignored = None, _kind: Ignored = Never) -&gt; bool:
    &#34;&#34;&#34;Always return `False`.&#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="castfit.to_never"><code class="name flex">
<span>def <span class="ident">to_never</span></span>(<span>value:Â Any) â€‘>Â NoReturn</span>
</code></dt>
<dd>
<div class="desc"><p>Always raise a <code>TypeError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(Never, NoReturn)
def to_never(value: Any, _kind: Ignored = Never) -&gt; NoReturn:
    &#34;&#34;&#34;Always raise a `TypeError`.&#34;&#34;&#34;
    raise TypeError(f&#34;Cannot cast {value!r} to Never (nothing can)&#34;)</code></pre>
</details>
</dd>
<dt id="castfit.is_none"><code class="name flex">
<span>def <span class="ident">is_none</span></span>(<span>value:Â Any) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code>value</code> is <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@checks_type(NoneType)
def is_none(value: Any, _kind: Ignored = None) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is `None`.&#34;&#34;&#34;
    return value is None</code></pre>
</details>
</dd>
<dt id="castfit.to_none"><code class="name flex">
<span>def <span class="ident">to_none</span></span>(<span>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Always return <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(NoneType)
def to_none(_value: Ignored = None, _kind: Ignored = None) -&gt; None:
    &#34;&#34;&#34;Always return `None`.&#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="castfit.is_literal"><code class="name flex">
<span>def <span class="ident">is_literal</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code>value</code> is a valid <code>Literal</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@checks_type(Literal)
def is_literal(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `Literal`.&#34;&#34;&#34;
    return value in get_args(kind)</code></pre>
</details>
</dd>
<dt id="castfit.to_literal"><code class="name flex">
<span>def <span class="ident">to_literal</span></span>(<span>value:Â T, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T]) â€‘>Â ~T</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>value</code> if it is one of the <code>Literal</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(Literal)
def to_literal(value: T, kind: TypeForm[T]) -&gt; T:
    &#34;&#34;&#34;Return `value` if it is one of the `Literal` values.&#34;&#34;&#34;
    if not is_literal(value, kind):
        raise TypeError(f&#34;Cannot cast {value!r} to {kind}&#34;)
    return value</code></pre>
</details>
</dd>
<dt id="castfit.is_union"><code class="name flex">
<span>def <span class="ident">is_union</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code>value</code> is a valid <code>Union</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@checks_type(Union)
def is_union(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `Union`.&#34;&#34;&#34;
    return any(is_type(value, val_type) for val_type in get_args(kind))</code></pre>
</details>
</dd>
<dt id="castfit.to_union"><code class="name flex">
<span>def <span class="ident">to_union</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T]) â€‘>Â ~T</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(Union)
def to_union(value: Any, kind: TypeForm[T]) -&gt; T:
    for arg in get_args(kind):
        try:
            return cast(T, to_type(value, arg))
        except (TypeError, ValueError):
            pass
    raise TypeError(f&#34;Cannot cast {value!r} to {kind}&#34;)</code></pre>
</details>
</dd>
<dt id="castfit.to_bytes"><code class="name flex">
<span>def <span class="ident">to_bytes</span></span>(<span>value:Â Any, kind:Â Type[bytes]Â =Â builtins.bytes) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Cast <code>value</code> into <code>bytes</code>, encoding <code>str</code> as UTF-8 bytes if needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(bytes)
def to_bytes(value: Any, kind: Type[bytes] = bytes) -&gt; bytes:
    &#34;&#34;&#34;Cast `value` into `bytes`, encoding `str` as UTF-8 bytes if needed.&#34;&#34;&#34;
    if isinstance(value, str):
        return value.encode(&#34;utf-8&#34;)
    cls: Type[bytes] = get_origin_type(kind)
    return cls(value)</code></pre>
</details>
</dd>
<dt id="castfit.to_str"><code class="name flex">
<span>def <span class="ident">to_str</span></span>(<span>value:Â Any, kind:Â Type[str]Â =Â builtins.str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Cast <code>value</code> into <code>str</code>, decoding <code>bytes</code> as UTF-8 strings if needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(str)
def to_str(value: Any, kind: Type[str] = str) -&gt; str:
    &#34;&#34;&#34;Cast `value` into `str`, decoding `bytes` as UTF-8 strings if needed.&#34;&#34;&#34;
    if isinstance(value, bytes):
        return value.decode(&#34;utf-8&#34;)
    cls: Type[str] = get_origin_type(kind)
    return cls(value)</code></pre>
</details>
</dd>
<dt id="castfit.is_list"><code class="name flex">
<span>def <span class="ident">is_list</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code>value</code> is a valid <code>list</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@checks_type(list)
def is_list(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `list`.&#34;&#34;&#34;
    if not isinstance(value, list):
        return False
    if len(value) == 0:  # list() matches List[Any]
        return True
    vt = get_args(kind)[0]
    return all(is_type(v, vt) for v in value)</code></pre>
</details>
</dd>
<dt id="castfit.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[List[T]]Â =Â builtins.list) â€‘>Â List[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Cast <code>value</code> into <code>list</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(list)
def to_list(value: Any, kind: TypeForm[List[T]] = list) -&gt; List[T]:
    &#34;&#34;&#34;Cast `value` into `list`.&#34;&#34;&#34;
    cls: Type[List[T]] = get_origin_type(kind)
    val_type = get_args(kind)[0]
    return cls(to_type(val, val_type) for val in value)</code></pre>
</details>
</dd>
<dt id="castfit.is_set"><code class="name flex">
<span>def <span class="ident">is_set</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code>value</code> is a valid <code>set</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@checks_type(set)
def is_set(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `set`.&#34;&#34;&#34;
    if not isinstance(value, set):
        return False
    if len(value) == 0:  # set() matches Set[Any]
        return True
    val_type = get_args(kind)[0]
    return all(is_type(val, val_type) for val in value)</code></pre>
</details>
</dd>
<dt id="castfit.to_set"><code class="name flex">
<span>def <span class="ident">to_set</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[Set[T]]Â =Â builtins.set) â€‘>Â Set[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Cast <code>value</code> into <code>set</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(set)
def to_set(value: Any, kind: TypeForm[Set[T]] = set) -&gt; Set[T]:
    &#34;&#34;&#34;Cast `value` into `set`.&#34;&#34;&#34;
    cls: Type[Set[T]] = get_origin_type(kind)
    val_type = get_args(kind)[0]
    return cls(to_type(val, val_type) for val in value)</code></pre>
</details>
</dd>
<dt id="castfit.is_dict"><code class="name flex">
<span>def <span class="ident">is_dict</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code>value</code> is a valid <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@checks_type(dict)
def is_dict(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `dict`.&#34;&#34;&#34;
    if not isinstance(value, dict):
        return False
    if len(value) == 0:  # dict() matches Dict[Any, Any]
        return True
    kt, vt = get_args(kind)
    return all(is_type(k, kt) and is_type(v, vt) for k, v in value.items())</code></pre>
</details>
</dd>
<dt id="castfit.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[Dict[K,Â T]]Â =Â builtins.dict) â€‘>Â Dict[~K,Â ~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Cast <code>value</code> into a <code>dict</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(dict)
def to_dict(value: Any, kind: TypeForm[Dict[K, T]] = dict) -&gt; Dict[K, T]:
    &#34;&#34;&#34;Cast `value` into a `dict`.&#34;&#34;&#34;
    cls: Type[Dict[K, T]] = get_origin_type(kind)
    if len(value) == 0:
        return cls()
    kt, vt = get_args(kind)
    return cls({to_type(k, kt): to_type(v, vt) for k, v in value.items()})</code></pre>
</details>
</dd>
<dt id="castfit.is_tuple"><code class="name flex">
<span>def <span class="ident">is_tuple</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[T]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if <code>value</code> is a valid <code>tuple</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@checks_type(tuple)
def is_tuple(value: Any, kind: TypeForm[T]) -&gt; bool:
    &#34;&#34;&#34;Return `True` if `value` is a valid `tuple`.&#34;&#34;&#34;
    args = get_args(kind)
    if not isinstance(value, tuple):
        return False
    if len(args) == 0 or args == ((),):  # special empty-tuple format
        return value == ()
    if len(args) &gt; 1 and args[1] == ...:
        args = args[:1] * len(value)
    return len(value) == len(args) and all(is_type(v, vt) for v, vt in zip(value, args))</code></pre>
</details>
</dd>
<dt id="castfit.to_tuple"><code class="name flex">
<span>def <span class="ident">to_tuple</span></span>(<span>value:Â Any, kind:Â <a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a>[Tuple[Any,Â ...]]Â =Â builtins.tuple) â€‘>Â Tuple[Any,Â ...]</span>
</code></dt>
<dd>
<div class="desc"><p>Cast <code>value</code> into a <code>tuple</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(tuple)
def to_tuple(value: Any, kind: TypeForm[Tuple[Any, ...]] = tuple) -&gt; Tuple[Any, ...]:
    &#34;&#34;&#34;Cast `value` into a `tuple`.&#34;&#34;&#34;
    cls: Type[Tuple[Any, ...]] = get_origin_type(kind)
    args = get_args(kind)
    if len(value) == 0 and len(args) == 0 or args == ((),):
        return cls()
    if len(args) &gt; 1 and args[1] == ...:
        args = args[:1] * len(value)
    if len(value) &lt; len(args):
        raise ValueError(f&#34;Not enough values in {value!r} to cast to {kind}&#34;)
    return cls(to_type(val, val_type) for val, val_type in zip(value, args))</code></pre>
</details>
</dd>
<dt id="castfit.to_datetime"><code class="name flex">
<span>def <span class="ident">to_datetime</span></span>(<span>value:Â Any, kind:Â Type[datetime]Â =Â datetime.datetime) â€‘>Â datetime.datetime</span>
</code></dt>
<dd>
<div class="desc"><p>Cast <code>value</code> into a <code>datetime</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@casts_to(datetime)
def to_datetime(value: Any, kind: Type[datetime] = datetime) -&gt; datetime:
    &#34;&#34;&#34;Cast `value` into a `datetime`.&#34;&#34;&#34;
    cls: Type[datetime] = get_origin_type(kind)
    # TODO: Handle other kinds of casts (e.g., int -&gt; datetime)
    return cls.fromisoformat(value)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="castfit.NoneType"><code class="flex name class">
<span>class <span class="ident">NoneType</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#why">Why?</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#license">License</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="two-column">
<li><code><a title="castfit.Ignored" href="#castfit.Ignored">Ignored</a></code></li>
<li><code><a title="castfit.TypeForm" href="#castfit.TypeForm">TypeForm</a></code></li>
<li><code><a title="castfit.CheckFn" href="#castfit.CheckFn">CheckFn</a></code></li>
<li><code><a title="castfit.Checks" href="#castfit.Checks">Checks</a></code></li>
<li><code><a title="castfit.CastFn" href="#castfit.CastFn">CastFn</a></code></li>
<li><code><a title="castfit.Casts" href="#castfit.Casts">Casts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="castfit.castfit" href="#castfit.castfit">castfit</a></code></li>
<li><code><a title="castfit.is_type" href="#castfit.is_type">is_type</a></code></li>
<li><code><a title="castfit.to_type" href="#castfit.to_type">to_type</a></code></li>
<li><code><a title="castfit.checks_type" href="#castfit.checks_type">checks_type</a></code></li>
<li><code><a title="castfit.casts_to" href="#castfit.casts_to">casts_to</a></code></li>
<li><code><a title="castfit.get_origin_type" href="#castfit.get_origin_type">get_origin_type</a></code></li>
<li><code><a title="castfit.setattrs" href="#castfit.setattrs">setattrs</a></code></li>
<li><code><a title="castfit.is_any" href="#castfit.is_any">is_any</a></code></li>
<li><code><a title="castfit.to_any" href="#castfit.to_any">to_any</a></code></li>
<li><code><a title="castfit.is_never" href="#castfit.is_never">is_never</a></code></li>
<li><code><a title="castfit.to_never" href="#castfit.to_never">to_never</a></code></li>
<li><code><a title="castfit.is_none" href="#castfit.is_none">is_none</a></code></li>
<li><code><a title="castfit.to_none" href="#castfit.to_none">to_none</a></code></li>
<li><code><a title="castfit.is_literal" href="#castfit.is_literal">is_literal</a></code></li>
<li><code><a title="castfit.to_literal" href="#castfit.to_literal">to_literal</a></code></li>
<li><code><a title="castfit.is_union" href="#castfit.is_union">is_union</a></code></li>
<li><code><a title="castfit.to_union" href="#castfit.to_union">to_union</a></code></li>
<li><code><a title="castfit.to_bytes" href="#castfit.to_bytes">to_bytes</a></code></li>
<li><code><a title="castfit.to_str" href="#castfit.to_str">to_str</a></code></li>
<li><code><a title="castfit.is_list" href="#castfit.is_list">is_list</a></code></li>
<li><code><a title="castfit.to_list" href="#castfit.to_list">to_list</a></code></li>
<li><code><a title="castfit.is_set" href="#castfit.is_set">is_set</a></code></li>
<li><code><a title="castfit.to_set" href="#castfit.to_set">to_set</a></code></li>
<li><code><a title="castfit.is_dict" href="#castfit.is_dict">is_dict</a></code></li>
<li><code><a title="castfit.to_dict" href="#castfit.to_dict">to_dict</a></code></li>
<li><code><a title="castfit.is_tuple" href="#castfit.is_tuple">is_tuple</a></code></li>
<li><code><a title="castfit.to_tuple" href="#castfit.to_tuple">to_tuple</a></code></li>
<li><code><a title="castfit.to_datetime" href="#castfit.to_datetime">to_datetime</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="castfit.NoneType" href="#castfit.NoneType">NoneType</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>